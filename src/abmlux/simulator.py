"""This file loads the agents, locations and network connections generated by the file
NetworkModel, together with the intial distributions and transition matrices generated by the
file MarkovModel, and simulates an epidemic. Note that the population size N is determined within
the file NetworkModel. In this file, one can set the length of the simulation in weeks and the
number of initial seeds. Note that the simulation starts on a Sunday and follows the SEIRD
framework."""

import logging
from collections import defaultdict

from abmlux.scheduler import Scheduler
from abmlux.messagebus import MessageBus

log = logging.getLogger('sim')

class Simulator:
    """Class that simulates an outbreak."""

    def __init__(self, state, reporters):

        # -------------------------------------------[ Config ]------------------------------------
        config                = state.config
        self.state            = state
        self.activity_manager = state.activity_manager
        self.clock            = state.clock
        self.bus              = state.bus

        self.prng          = state.prng
        self.network       = state.network
        self.locations     = state.network.locations
        self.agents        = state.network.agents
        self.disease       = state.disease
        self.interventions = state.interventions.keys()

        # Read-only config
        self.reporters               = reporters

        self.agent_updates = defaultdict(dict)
        self.bus.subscribe("request.agent.location", self.record_location_change, self)
        self.bus.subscribe("request.agent.activity", self.record_activity_change, self)
        self.bus.subscribe("request.agent.health", self.record_health_change, self)

        # For reporting
        self.agents_by_health_state = {h: {a for a in self.agents if a.health == h}
                                       for h in self.disease.states}

        # For manipulating interventions
        self.scheduler = Scheduler(self.clock, self.bus, state.intervention_schedules)

    def record_location_change(self, agent, new_location):
        """Record request.agent.location events, placing them on a queue to be enacted
        at the end of the tick."""

        self.agent_updates[agent]['location'] = new_location
        return MessageBus.CONSUME

    def record_activity_change(self, agent, new_activity):
        """Record request.agent.activity events, placing them on a queue to be enacted
        at the end of the tick.

        If the activity is changing, this may trigger a change in location, e.g. a change to a
        'home' activity will cause this function to emit a request to move the agent to its home.
        """

        self.agent_updates[agent]['activity'] = new_activity
        return MessageBus.CONSUME

    def record_health_change(self, agent, new_health):
        """Record request.agent.health events, placing them on a queue to be enacted
        at the end of the tick.

        Certain changes in health state will cause agents to request changes of location, e.g.
        to a hospital."""

        self.agent_updates[agent]['health'] = new_health
        return MessageBus.CONSUME

    def run(self):
        """Run the simulation"""

        log.info("Simulating outbreak...")
        for reporter in self.reporters:
            reporter.start(self)

        # Initialize interventions here?
        self.clock.reset()
        current_day = self.clock.now().day

        self.bus.publish("notify.time.start_simulation", self)


        # Caches
        # Simulation state.  These indices represent an optimisation to prevent having to loop
        # over every single agent.
        log.info("Creating agent location indices...")
        self.attendees                     = {l: {a for a in self.agents if a.current_location == l}
                                              for l in self.locations}

        # Disease model parameters
        log.info("Creating health state indices...")
        self.agents_by_health_state        = {h: {a for a in self.agents if a.health == h}
                                              for h in self.disease.states}
        # /caches

        update_notifications = []
        for t in self.clock:

            # Send out notifications of what has changed since last tick
            for topic, *params in update_notifications:
                self.bus.publish(topic, *params)

            # Send tick event --- things respond to this with intents
            self.bus.publish("notify.time.tick", self.clock, t)
            if current_day != self.clock.now().day:
                current_day = self.clock.now().day
                self.bus.publish("notify.time.midnight", self.clock, t)

            # - 3 - Actually enact changes in an atomic manner
            update_notifications = self._update_agents()

            # 4. Inform reporters of state
            for reporter in self.reporters:
                reporter.iterate(self)

        self.bus.publish("notify.time.end_simulation", self)

        for reporter in self.reporters:
            reporter.stop(self)


    def _update_agents(self):
        """Update the state of agents according to the lists provided."""

        update_notifications = []

        for agent, updates in self.agent_updates.items():

            # -------------------------------------------------------------------------------------
            if 'health' in updates:

                # Remove from index
                self.agents_by_health_state[agent.health].remove(agent)
                #self.agent_counts_by_health[agent.health][agent.current_location] -= 1

                # Update
                old_health = agent.health
                agent.health = updates['health']

                # Add to index
                self.agents_by_health_state[agent.health].add(agent)
                #self.agent_counts_by_health[agent.health][agent.current_location] += 1
                update_notifications.append(("notify.agent.health", agent, old_health))

            # -------------------------------------------------------------------------------------
            if 'activity' in updates:

                old_activity = agent.current_activity
                agent.set_activity(updates['activity'])
                update_notifications.append(("notify.agent.activity", agent, old_activity))

            # -------------------------------------------------------------------------------------
            if 'location' in updates:

                # Update indices and set activity
                #self.agent_counts_by_health[agent.health][agent.current_location] -= 1
                self.attendees[agent.current_location].remove(agent)

                old_location = agent.current_location
                agent.set_location(updates['location'])

                self.attendees[agent.current_location].add(agent)
                #self.agent_counts_by_health[agent.health][agent.current_location] += 1

                update_notifications.append(("notify.agent.location", agent, old_location))

        self.agent_updates = defaultdict(dict)
        return update_notifications

"""This file loads the agents, locations and network connections generated by the file
NetworkModel, together with the intial distributions and transition matrices generated by the
file MarkovModel, and simulates an epidemic. Note that the population size N is determined within
the file NetworkModel. In this file, one can set the length of the simulation in weeks and the
number of initial seeds. Note that the simulation starts on a Sunday and follows the SEIRD
framework."""

import logging
from collections import defaultdict

import abmlux.random_tools as random_tools
from .sim_time import SimClock
from abmlux.messagebus import MessageBus

log = logging.getLogger('sim')

class Simulator:
    """Class that simulates an outbreak."""

    def __init__(self, state, reporters):

        # -------------------------------------------[ Config ]------------------------------------
        config                = state.config
        self.state            = state
        self.activity_manager = state.activity_manager
        self.clock            = state.clock
        self.bus              = state.bus

        self.prng          = state.prng
        self.network       = state.network
        self.locations     = state.network.locations
        self.agents        = state.network.agents
        self.disease       = state.disease
        self.interventions = state.interventions

        # Read-only config
        self.activity_transitions    = state.activity_transitions
        self.reporters               = reporters

        # Simulation state.  These indices represent an optimisation to prevent having to loop
        # over every single agent.
        log.info("Creating agent location indices...")
        self.attendees                     = {l: {a for a in self.agents if a.current_location == l}
                                              for l in self.locations}

        # Disease model parameters
        log.info("Creating health state indices...")
        self.agents_by_health_state        = {h: {a for a in self.agents if a.health == h}
                                              for h in self.disease.states}
        self.agent_counts_by_health = {h: {l: len([a for a in self.attendees[l] if a.health == h])
                                           for l in self.locations}
                                       for h in self.disease.states}
        self.cemeteries      = state.network.locations_by_type['Cemetery']
        self.hospitals       = state.network.locations_by_type['Hospital']
        self.dead_states     = config['dead_states']
        self.hospital_states = config['hospital_states']

        self.agent_updates = defaultdict(dict)
        self.bus.subscribe("request.location.change", self.handle_location_change, self)
        self.bus.subscribe("agent.activity.change", self.handle_activity_change, self)
        self.bus.subscribe("agent.health.change", self.handle_health_change, self)
        self.bus.subscribe("notify.time.tick", self._get_activity_transitions, self)

    def handle_location_change(self, agent, new_location):
        self.agent_updates[agent]['location'] = new_location
        return MessageBus.CONSUME

    def handle_activity_change(self, agent, new_activity):
        self.agent_updates[agent]['activity'] = new_activity

        # If agent is hospitalised or dead, don't change location in response to new activity
        if agent.health in self.hospital_states or agent.health in self.dead_states:
            return

        # Change location in response to new activity
        allowable_locations = agent.locations_for_activity(self.agent_updates[agent]['activity'])
        self.bus.publish("request.location.change", agent, \
                         random_tools.random_choice(self.prng, list(allowable_locations)))
        return MessageBus.CONSUME
    
    def handle_health_change(self, agent, new_health):
        self.agent_updates[agent]['health'] = new_health

        # If at time t the function get_health_transitions outputs 'HOSPITALIZING' for an agent,
        # then the function _get_activity_transitions will move that agent to hospital at the
        # first time, greater than or equal to t+1, at which the agent chooses to perform a new
        # activity. In other words, agents will finish the current activity before moving to
        # hospital, and similarly as regards leaving hospital. This simple implementation could
        # be modified by allowing activity_changes at time t to depend on health_changes at time
        # t and moreover by allowing agents to enter and exit hospital independently of their
        # Markov chain.
        if new_health in self.hospital_states:
            if agent.current_location not in self.hospitals:
                self.bus.publish("request.location.change", agent, random_tools.random_choice(self.prng, self.hospitals))
        elif agent.health in self.dead_states:
            if agent.current_location not in self.cemeteries:
                self.bus.publish("request.location.change", agent, random_tools.random_choice(self.prng, self.cemeteries))

        return MessageBus.CONSUME

    def run(self):
        """Run the simulation"""

        log.info("Simulating outbreak...")
        for reporter in self.reporters:
            reporter.start(self)

        # Initialize interventions here?
        self.clock.reset()
        current_day = self.clock.now().day

        self.bus.publish("notify.time.start_simulation", self)
        update_notifications = []
        for t in self.clock:

            # Send out notifications of what has changed since last tick
            for topic, *params in update_notifications:
                self.bus.publish(topic, *params)

            # Send tick event --- things respond to this with intents
            self.bus.publish("notify.time.tick", self.clock, t)
            if current_day != self.clock.now().day:
                current_day = self.clock.now().day
                self.bus.publish("notify.time.midnight", self.clock, t)

            # - 3 - Actually enact changes in an atomic manner
            update_notifications = self._update_agents()

            # 4. Inform reporters of state
            for reporter in self.reporters:
                reporter.iterate(self)
        
        self.bus.publish("notify.time.end_simulation", self)

        for reporter in self.reporters:
            reporter.stop(self)

    def _get_activity_transitions(self, clock, t):
        """Return a list of activity transitions agents should enact this tick.

        The list is given as a list of three-tuples, each containing the agent,
        activity, and location to perform that activity: (agent, activity, location)."""

        for agent in self.agents:

            if self.activity_transitions[agent.agetyp][self.clock.ticks_through_week()]\
               .get_no_trans(agent.current_activity):
                continue

            next_activity = self.activity_transitions[agent.agetyp]\
                            [self.clock.ticks_through_week()]\
                            .get_transition(agent.current_activity)

            self.bus.publish("agent.activity.change", agent, next_activity)

    def _update_agents(self):
        """Update the state of agents according to the lists provided."""

        update_notifications = []

        for agent, updates in self.agent_updates.items():

            # -------------------------------------------------------------------------------------
            if 'health' in updates:

                # Remove from index
                self.agents_by_health_state[agent.health].remove(agent)
                self.agent_counts_by_health[agent.health][agent.current_location] -= 1

                # Update
                old_health = agent.health
                agent.health = updates['health']

                # Add to index
                self.agents_by_health_state[agent.health].add(agent)
                self.agent_counts_by_health[agent.health][agent.current_location] += 1
                update_notifications.append(("notify.agent.health", agent, old_health))

            # -------------------------------------------------------------------------------------
            if 'activity' in updates:

                old_activity = agent.current_activity
                agent.set_activity(updates['activity'])
                update_notifications.append(("notify.agent.activity", agent, old_activity))

            # -------------------------------------------------------------------------------------
            if 'location' in updates:

                # Update indices and set activity
                self.agent_counts_by_health[agent.health][agent.current_location] -= 1
                self.attendees[agent.current_location].remove(agent)
                
                old_location = agent.current_location
                agent.set_location(updates['location'])
                
                self.attendees[agent.current_location].add(agent)
                self.agent_counts_by_health[agent.health][agent.current_location] += 1
                
                
                update_notifications.append(("notify.agent.location", agent, old_location))

        self.agent_updates = defaultdict(dict)
        return update_notifications



#!/usr/bin/env python3

#ABM5
#This file loads the agents, locations and network connections generated by the file NetworkModel, to
#gether with the intial distributions and transition matrices generated by the file MarkovModel, and
#simulates an epidemic. Note that the population size N is determined within the file NetworkModel. I
#n this file, one can set the length of the simulation in weeks and the number of initial seeds. Note
#that the simulation starts on a Sunday and follows the SEIRD framework.

import os.path as osp
import sys
import math
import random
import pickle
import logging

import numpy as np
import pandas as pd
from tqdm import tqdm

from .agent import Agent, AgentType, POPULATION_SLICES, HealthStatus
from .location import Location
from .sim_time import SimClock
from .activity import ActivityManager
import abmlux.utils as utils
import abmlux.random_tools as random_tools

log = logging.getLogger('sim')

def run_model(config, network, initial_activity_distributions, activity_transition_matrix):

    # ------------------------------------------------[ Config ]------------------------------------
    activity_manager = ActivityManager(config['activities'])
    clock            = SimClock(config['tick_length_s'], config['simulation_length_days'])


    # ------------------------------------------------[ Agents ]------------------------------------
    locations_by_type = network.locations_by_type
    locations         = network.locations
    agents_by_type    = network.agents_by_type
    agents            = network.agents


    # ------------------------------------------------[ Locations ]------------------------------------
    log.debug('Preparing pathogenic data...')

    incubation_ticks = clock.days_to_ticks(config['incubation_period_days'])
    infectious_ticks = clock.days_to_ticks(config['infectious_period_days'])

    def get_p_death_func(p_death_config):
        """Return a function that takes an age and returns
        the absolute probability of death at the end of the
        infectious period"""

        # Make a slow lookup by checking the range.
        #
        # Assumes no overlapping ranges.
        def p_death_slow(age):
            for rng, p in p_death_config:
                if age >= rng[0] and age < rng[1]:
                    return p
            return 0.0

        # Make a fast lookup. and use this for integers.
        # Fall through to the slow one if not in the list
        oldest_item = max([x[0][1] for x in p_death_config])
        fast_lookup = [p_death_slow(x) for x in range(0, oldest_item)]
        def p_death_fast(age):
            if age in fast_lookup:
                return fast_lookup[age]
            return p_death_slow(age)

        return p_death_fast

    p_death = get_p_death_func(config['probability_of_death'])



    # If two individuals, one susceptible and one infectious, spend ten minutes together in location j,
    # then prob[j] is the average number of times, out of 10000 trials, that the susceptible will become
    # infected:
    p_transmit_by_location_type = {x: y for x, y in config['infection_probabilities_per_tick'].items()}



    # ------------------------------------------[ Initial state ]------------------------------------
    log.debug(f"Loading initial state for simulation...")
    # Infect a few people
    for agent in random.sample(agents, k=config['initial_infections']):
        agent.health = HealthStatus.INFECTED

    log.debug(f"Seeding initial activity states and locations...")
    for agent in agents:
        # allowed_locations = []
        # while len(allowed_locations) == 0:
        new_activity           = random_tools.multinoulli_dict(initial_activity_distributions[agent.agetyp])
        allowed_location_types = activity_manager.get_location_types(new_activity)
        allowed_locations      = agent.find_allowed_locations_by_type(allowed_location_types)

        if len(allowed_locations) == 0:
            log.warn(f"Warning: No allowed locations found for agent {agent.inspect()} for activity {new_activity}"\
                     f" (allowed location types={allowed_location_types})."\
                     f"  Will resample from the starting distribution, but this is not ideal.")

        # Do this activity in this location
        agent.set_activity(new_activity, random.choice(list(allowed_locations)))



    # ------------------------------------------------[ Simulate! ]------------------------------------
    log.info(f"Simulating outbreak...")
    # Finally the epidemic can be simulated. In each ten minute interval, the code first loops through all
    # locations, in which the health status of individuals is updated, after which it loops through all 
    # individuals, in which the locations of individuals are updated. Note that individuals only change 
    # location if the Markov chain generates a new activity. For example, once an individual is inside a shop,
    # they cannot move directly to another shop.


    def infectious_agents_by_location(locations):
        """Returns a key-value mapping of locations to the number of
        infectious agents at that location.  Used to compute the probability that an agent
        will catch the pathogen when at that location."""

        infectious_count = {l: len([a for a in l.attendees if a.health == HealthStatus.INFECTED]) for l in locations}
        return infectious_count

    def get_agent_transition(agent, time_in_week, infected_count_by_location=None):

        # The dead don't participate
        if agent.health == HealthStatus.DEAD:
            return

        next_health   = None
        next_activity = None
        next_location = None

        # --- If susceptible, risk of infection from all infected people 
        #     at the current location ---
        if agent.health == HealthStatus.SUSCEPTIBLE:
            location = agent.current_location

            # If we have been handed a cache object then use this, else
            # we have to recompute for every agent, which takes a while.
            num_infectious_agents = infected_count_by_location[location]
            p_infection           = config['infection_probabilities_per_tick'][location.typ]

            # We'll be exposed n times, so compute a new overall probability of catching
            # the virus from at least one person:
            p_infection = 1 - (1-p_infection)**num_infectious_agents
            if random_tools.boolean(p_infection):
                next_health = HealthStatus.EXPOSED

        # --- Update health status ---
        if agent.health == HealthStatus.EXPOSED:
            # If we have incubated for long enough, become infected
            ticks_since_exposure = t - agent_health_state_change_time[agent]
            if ticks_since_exposure > incubation_ticks:
                next_health = HealthStatus.INFECTED
        elif agent.health == HealthStatus.INFECTED:
            # If we have been infected for long enough, become uninfected (i.e.
            # dead or recovered)
            ticks_since_infection = t - agent_health_state_change_time[agent]
            if ticks_since_infection > infectious_ticks:
                # die or recover?
                if random_tools.boolean(p_death(agent.age)):
                    next_health = HealthStatus.DEAD
                else:
                    next_health = HealthStatus.RECOVERED

        # --- Update activity status ---
        weighted_next_activity_options = activity_transition_matrix[agent.agetyp][time_in_week][agent.current_activity]
        possible_next_activity         = random_tools.multinoulli_dict(weighted_next_activity_options)

        if possible_next_activity != agent.current_activity:
            allowable_location_types = activity_manager.get_location_types(possible_next_activity)
            allowable_locations      = agent.find_allowed_locations_by_type(allowable_location_types)

            next_activity = possible_next_activity
            next_location = random.choice(list(allowable_locations))

        # Return a 3-tuple if we have done anything, else None
        if next_health is not None or next_activity is not None or next_location is not None:
            return next_health, next_activity, next_location
        return None


    # For each agent, record where it is going next.  Entries are (HealthStatus, activity, location)
    # 3-tuples, indexed by agent.
    agent_health_state_change_time = {a: 0 for a in agents}
    health_status_by_time = {h.name: [] for h in list(HealthStatus)}
    for t in clock:


        # Move people around the network
        time_in_week = int(t % clock.ticks_in_week) # How far through the week are we, in ticks?

        # Compute next state for each agent
        infectious_agents_cache = infectious_agents_by_location(locations)
        next_agent_state = {}
        for agent in agents:
            transition = get_agent_transition(agent, time_in_week, infectious_agents_cache)
            if transition is not None:
                next_agent_state[agent] = transition

        # Update states according to markov chain
        for agent, transition in next_agent_state.items():

            next_health, next_activity, next_location = transition

            if next_health is not None:
                agent.health = next_health
            if next_activity is not None:
                agent.set_activity(next_activity, next_location)


        # Count statuses, adding a row to the counts
        for h in list(HealthStatus):
            health_status_by_time[h.name].append( len([a for a in agents if a.health == h]) )


        status = {h.name: health_status_by_time[h.name][t-1] for h in list(HealthStatus)}
        log.debug(f"[{t}] {clock.time_elapsed()} elapsed.   {status}.  {len(next_agent_state)} state changes.")

    # ------------------------------------------------[ Return output ]------------------------------------
    return health_status_by_time


    # FIXME: - House and Other House don't function correctly
    #        - No logging of stats as the sim runs

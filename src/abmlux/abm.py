#!/usr/bin/env python3

#ABM5
#This file loads the agents, locations and network connections generated by the file NetworkModel, to
#gether with the intial distributions and transition matrices generated by the file MarkovModel, and
#simulates an epidemic. Note that the population size N is determined within the file NetworkModel. I
#n this file, one can set the length of the simulation in weeks and the number of initial seeds. Note
#that the simulation starts on a Sunday and follows the SEIRD framework.

import os.path as osp
import sys
import math
import random
import pickle
import logging

import numpy as np
import pandas as pd
from tqdm import tqdm

from .agent import Agent, AgentType, POPULATION_SLICES, HealthStatus
from .location import Location
from .sim_time import SimClock
from .activity import ActivityManager
import abmlux.utils as utils
import abmlux.random_tools as random_tools

log = logging.getLogger('sim')




def get_p_death_func(p_death_config):
    """Return a function that takes an age and returns
    the absolute probability of death at the end of the
    infectious period"""

    # Make a slow lookup by checking the range.
    #
    # Assumes no overlapping ranges.
    def p_death_slow(age):
        for rng, p in p_death_config:
            if age >= rng[0] and age < rng[1]:
                return p
        return 0.0

    # Make a fast lookup. and use this for integers.
    # Fall through to the slow one if not in the list
    oldest_item = max([x[0][1] for x in p_death_config])
    fast_lookup = [p_death_slow(x) for x in range(0, oldest_item)]
    def p_death_fast(age):
        if age in fast_lookup:
            return fast_lookup[age]
        return p_death_slow(age)

    return p_death_fast






def get_activity_transitions(agents, ticks_through_week, activity_transitions):

    next_activities = []

    for agent in agents:

        if activity_transitions[agent.agetyp][ticks_through_week].get_no_trans(agent.current_activity):
            continue

        next_activity       = activity_transitions[agent.agetyp][ticks_through_week].get_transition(agent.current_activity)
        allowable_locations = agent.locations_for_activity(next_activity)

        next_activities.append( (agent, next_activity, random.choice(list(allowable_locations))) )

    return next_activities




def get_health_transitions(t, agents_by_health_state, infectious_agents_by_location, infection_probabilities_per_tick,
                          agent_health_state_change_time, incubation_ticks, infectious_ticks, p_death):
    """Return a list of health transitions agents should enact this tick"""

    next_health   = []
 
    # We'll be exposed n times, so compute a new overall probability of catching
    # the virus from at least one person:
    infection_probability_by_location = {l: 1 - (1-infection_probabilities_per_tick[l.typ])**c
                                         for l, c in infectious_agents_by_location.items()
                                         if c > 0}
    for agent in agents_by_health_state[HealthStatus.SUSCEPTIBLE]:

        # Read useful things
        location = agent.current_location
        if infectious_agents_by_location[location] == 0:
            continue

        if random_tools.boolean(infection_probability_by_location[location]):
            next_health.append((agent, HealthStatus.EXPOSED))


    for agent in agents_by_health_state[HealthStatus.EXPOSED]:
        time_since_state_change = t - agent_health_state_change_time[agent]

        # If we have incubated for long enough, become infected
        if time_since_state_change > incubation_ticks:
            next_health.append((agent, HealthStatus.INFECTED))



    for agent in agents_by_health_state[HealthStatus.INFECTED]:
        time_since_state_change = t - agent_health_state_change_time[agent]
        # If we have been infected for long enough, become uninfected (i.e.
        # dead or recovered)
        if time_since_state_change > infectious_ticks:
            # die or recover?
            if random_tools.boolean(p_death(agent.age)):
                next_health.append((agent, HealthStatus.DEAD))
            else:
                next_health.append((agent, HealthStatus.RECOVERED))
 
    return next_health







def update_agents(t, agents_by_health_state, infectious_agents_by_location, health_state_change_time, health_changes, activity_changes):

        # 2.1 - Update health status
        for agent, new_health in health_changes:

            # Remove from index
            agents_by_health_state[agent.health].remove(agent)
            if agent.health == HealthStatus.INFECTED:
                infectious_agents_by_location[agent.current_location] -= 1

            # Update
            agent.health                    = new_health
            health_state_change_time[agent] = t

            # Add to index
            agents_by_health_state[agent.health].add(agent)
            if agent.health == HealthStatus.INFECTED:
                infectious_agents_by_location[agent.current_location] += 1


        # 2.2 - Update activity
        for agent, new_activity, new_location in activity_changes:

            # Update index
            if agent.health == HealthStatus.INFECTED:
                infectious_agents_by_location[agent.current_location] -= 1
                infectious_agents_by_location[new_location] += 1

            # Update
            agent.set_activity(new_activity, new_location)





def run_model(config, network, activity_distributions, activity_transitions):

    # ------------------------------------------------[ Config ]------------------------------------
    activity_manager = ActivityManager(config['activities'])
    clock            = SimClock(config['tick_length_s'], config['simulation_length_days'], config['epoch'])


    # ------------------------------------------------[ Agents ]------------------------------------
    locations         = network.locations
    agents            = network.agents


    # ------------------------------------------------[ Locations ]------------------------------------
    log.debug('Preparing pathogenic data...')

    incubation_ticks = clock.days_to_ticks(config['incubation_period_days'])
    infectious_ticks = clock.days_to_ticks(config['infectious_period_days'])

    p_death = get_p_death_func(config['probability_of_death'])

    # ------------------------------------------[ Initial state ]------------------------------------
    log.debug(f"Loading initial state for simulation...")
    # Infect a few people
    for agent in random.sample(agents, k=config['initial_infections']):
        agent.health = HealthStatus.INFECTED

    log.debug(f"Seeding initial activity states and locations...")
    for agent in agents:

        # Get distribution for this type at the starting time step
        distribution = activity_distributions[agent.agetyp][clock.epoch_week_offset]
        assert sum(distribution.values()) > 0
        new_activity      = random_tools.multinoulli_dict(distribution)
        allowed_locations = agent.locations_for_activity(new_activity)

        if len(allowed_locations) == 0:
            log.warn(f"Warning: No allowed locations found for agent {agent.inspect()} for activity {new_activity}"\
                     f"  Will resample from the starting distribution, but this is not ideal.")

        new_location = random.choice(list(allowed_locations))

        # Do this activity in a random location
        agent.set_activity(new_activity, new_location)




    # ------------------------------------------------[ Simulate! ]------------------------------------
    log.info(f"Simulating outbreak...")
    # Finally the epidemic can be simulated. In each ten minute interval, the code first loops through all
    # locations, in which the health status of individuals is updated, after which it loops through all 
    # individuals, in which the locations of individuals are updated. Note that individuals only change 
    # location if the Markov chain generates a new activity. For example, once an individual is inside a shop,
    # they cannot move directly to another shop.


    # These lists keep track of the simulation.  This is an optimisation to prevent us from
    # having to loop over every agent at every tick
    health_state_change_time      = {a: 0 for a in agents}
    infectious_agents_by_location = {l: len([a for a in l.attendees if a.health == HealthStatus.INFECTED]) for l in locations}
    agents_by_health_state        = {h: set([a for a in agents if a.health == h]) for h in list(HealthStatus)}

    for t in tqdm(clock):

        # - 1 - Compute changes and pop them on the list
        health_changes =  get_health_transitions(t, agents_by_health_state, infectious_agents_by_location,
                                                 config['infection_probabilities_per_tick'],
                                                 health_state_change_time, incubation_ticks,
                                                 infectious_ticks, p_death)

        activity_changes = get_activity_transitions(agents, clock.ticks_through_week(), activity_transitions)

        print(f"[{t}: {clock.now()}] { {k.name[0]: len(v) for k, v in agents_by_health_state.items()} }, {len(health_changes)} dhealth, {len(activity_changes)} dactivity")

        # - 2 - Actually enact changes in an atomic manner
        update_agents(t, agents_by_health_state, infectious_agents_by_location,
                      health_state_change_time, health_changes, activity_changes)



    # ------------------------------------------------[ Return output ]------------------------------------
    return None


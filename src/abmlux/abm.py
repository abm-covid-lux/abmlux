#!/usr/bin/env python3

#ABM5
#This file loads the agents, locations and network connections generated by the file NetworkModel, to
#gether with the intial distributions and transition matrices generated by the file MarkovModel, and
#simulates an epidemic. Note that the population size N is determined within the file NetworkModel. I
#n this file, one can set the length of the simulation in weeks and the number of initial seeds. Note
#that the simulation starts on a Sunday and follows the SEIRD framework.

import os.path as osp
import sys
import math
import random
import pickle
import logging

import numpy as np
import pandas as pd
from tqdm import tqdm
import dateparser

from .agent import Agent, AgentType, POPULATION_SLICES, HealthStatus
from .location import Location
from .sim_time import SimClock
from .activity import ActivityManager
import abmlux.utils as utils
import abmlux.random_tools as random_tools

log = logging.getLogger('sim')






def get_p_death_func(p_death_config):
    """Return a function that takes an age and returns
    the absolute probability of death at the end of the
    infectious period"""

    # Make a slow lookup by checking the range.
    #
    # Assumes no overlapping ranges.
    def p_death_slow(age):
        for rng, p in p_death_config:
            if age >= rng[0] and age < rng[1]:
                return p
        return 0.0

    # Make a fast lookup. and use this for integers.
    # Fall through to the slow one if not in the list
    oldest_item = max([x[0][1] for x in p_death_config])
    fast_lookup = [p_death_slow(x) for x in range(0, oldest_item)]
    def p_death_fast(age):
        if age in fast_lookup:
            return fast_lookup[age]
        return p_death_slow(age)

    return p_death_fast






def get_agent_transition(agent, weekday, time_since_state_change, infectious_agents_by_location, infection_probabilities_per_tick,
                         activity_transition_matrix, infectious_ticks, incubation_ticks, p_death):

    # The dead don't participate
    if agent.health == HealthStatus.DEAD:
        return

    next_health   = None
    next_activity = None
    next_location = None

    # --- If susceptible, risk of infection from all infected people
    #     at the current location ---
    if agent.health == HealthStatus.SUSCEPTIBLE:
        location = agent.current_location

        # If we have been handed a cache object then use this, else
        # we have to recompute for every agent, which takes a while.
        num_infectious_agents = infectious_agents_by_location[location]
        p_infection           = infection_probabilities_per_tick[location.typ]

        # We'll be exposed n times, so compute a new overall probability of catching
        # the virus from at least one person:
        p_infection = 1 - (1-p_infection)**num_infectious_agents
        if random_tools.boolean(p_infection):
            next_health = HealthStatus.EXPOSED

    # --- Update health status ---
    if agent.health == HealthStatus.EXPOSED:
        # If we have incubated for long enough, become infected
        if time_since_state_change > incubation_ticks:
            next_health = HealthStatus.INFECTED
    elif agent.health == HealthStatus.INFECTED:
        # If we have been infected for long enough, become uninfected (i.e.
        # dead or recovered)
        if time_since_state_change > infectious_ticks:
            # die or recover?
            if random_tools.boolean(p_death(agent.age)):
                next_health = HealthStatus.DEAD
            else:
                next_health = HealthStatus.RECOVERED

    # --- Update activity status ---
    weighted_next_activity_options = activity_transition_matrix[agent.agetyp][weekday][agent.current_activity]
    possible_next_activity         = random_tools.multinoulli_dict(weighted_next_activity_options)

    if possible_next_activity != agent.current_activity:
        allowable_locations = agent.locations_for_activity(possible_next_activity)

        next_activity = possible_next_activity
        next_location = random.choice(list(allowable_locations))

    # Return a 3-tuple if we have done anything, else None
    if next_health is not None or next_activity is not None or next_location is not None:
        return next_health, next_activity, next_location

    return None






def run_model(config, network, initial_activity_distributions, activity_transition_matrix):

    # ------------------------------------------------[ Config ]------------------------------------
    activity_manager = ActivityManager(config['activities'])
    clock            = SimClock(config['tick_length_s'], config['simulation_length_days'], dateparser.parse(config['epoch']))


    # ------------------------------------------------[ Agents ]------------------------------------
    locations_by_type = network.locations_by_type
    locations         = network.locations
    agents_by_type    = network.agents_by_type
    agents            = network.agents


    # ------------------------------------------------[ Locations ]------------------------------------
    log.debug('Preparing pathogenic data...')

    incubation_ticks = clock.days_to_ticks(config['incubation_period_days'])
    infectious_ticks = clock.days_to_ticks(config['infectious_period_days'])

    p_death = get_p_death_func(config['probability_of_death'])



    # If two individuals, one susceptible and one infectious, spend ten minutes together in location j,
    # then prob[j] is the average number of times, out of 10000 trials, that the susceptible will become
    # infected:
    p_transmit_by_location_type = {x: y for x, y in config['infection_probabilities_per_tick'].items()}



    # ------------------------------------------[ Initial state ]------------------------------------
    log.debug(f"Loading initial state for simulation...")
    # Infect a few people
    for agent in random.sample(agents, k=config['initial_infections']):
        agent.health = HealthStatus.INFECTED

    log.debug(f"Seeding initial activity states and locations...")
    for agent in agents:
        new_activity           = random_tools.multinoulli_dict(initial_activity_distributions[agent.agetyp])
        allowed_locations      = agent.locations_for_activity(new_activity)

        if len(allowed_locations) == 0:
            log.warn(f"Warning: No allowed locations found for agent {agent.inspect()} for activity {new_activity}"\
                     f"  Will resample from the starting distribution, but this is not ideal.")

        new_location = random.choice(list(allowed_locations))

        # Do this activity in a random location
        agent.set_activity(new_activity, new_location)




    # ------------------------------------------------[ Simulate! ]------------------------------------
    log.info(f"Simulating outbreak...")
    # Finally the epidemic can be simulated. In each ten minute interval, the code first loops through all
    # locations, in which the health status of individuals is updated, after which it loops through all 
    # individuals, in which the locations of individuals are updated. Note that individuals only change 
    # location if the Markov chain generates a new activity. For example, once an individual is inside a shop,
    # they cannot move directly to another shop.


    # For each agent, record where it is going next.  Entries are (HealthStatus, activity, location)
    # 3-tuples, indexed by agent.
    agent_health_state_change_time = {a: 0 for a in agents}
    health_status_by_time          = {h.name: [] for h in list(HealthStatus)}
    infectious_agents_by_location  = {l: len([a for a in l.attendees if a.health == HealthStatus.INFECTED]) for l in locations}
    for t in tqdm(clock):

        # Move people around the network
        weekday = clock.now().weekday()

        # Compute next state for each agent
        next_agent_state = {}
        for agent in agents:
            transition = get_agent_transition(agent, weekday, t - agent_health_state_change_time[agent], infectious_agents_by_location,
                                              config['infection_probabilities_per_tick'], activity_transition_matrix, infectious_ticks,
                                              incubation_ticks, p_death)
            if transition is not None:
               next_agent_state[agent] = transition

        # Update states according to markov chain
        for agent, transition in next_agent_state.items():

            next_health, next_activity, next_location = transition

            if next_activity is not None:
                # When an infected agent leaves a location, deduct from the running total
                if agent.health == HealthStatus.INFECTED:
                    infectious_agents_by_location[agent.current_location] -= 1

                agent.set_activity(next_activity, next_location)

                # When an infected agent moves to a location, increment the running total
                if agent.health == HealthStatus.INFECTED:
                    infectious_agents_by_location[agent.current_location] += 1

            if next_health is not None:

                # When an infected agent becomes uninfected, decrement counter
                if agent.health == HealthStatus.INFECTED and next_health != HealthStatus.INFECTED:
                    infectious_agents_by_location[agent.current_location] -= 1

                agent.health = next_health

                # When an uninfected agent becomes infected, increment counter
                if agent.health != HealthStatus.INFECTED and next_health == HealthStatus.INFECTED:
                    infectious_agents_by_location[agent.current_location] += 1


        # Count statuses, adding a row to the counts
        for h in list(HealthStatus):
            health_status_by_time[h.name].append( len([a for a in agents if a.health == h]) )

        log.debug(f"[{t}/{clock.max_ticks} ({100*t/clock.max_ticks :0.2f}%)] {clock.now()}.   "
                  f"{{h.name: health_status_by_time[h.name][t-1] for h in list(HealthStatus)}}.  {len(next_agent_state)} state changes.")

    # ------------------------------------------------[ Return output ]------------------------------------
    return health_status_by_time


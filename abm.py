#!/usr/bin/env python3

#ABM5
#This file loads the agents, locations and network connections generated by the file NetworkModel, to
#gether with the intial distributions and transition matrices generated by the file MarkovModel, and
#simulates an epidemic. Note that the population size N is determined within the file NetworkModel. I
#n this file, one can set the length of the simulation in weeks and the number of initial seeds. Note
#that the simulation starts on a Sunday and follows the SEIRD framework.

import math
import random
import pickle

import numpy as np
import matplotlib.pyplot as plt
import xlsxwriter
from openpyxl import load_workbook
import pandas as pd
from tqdm import tqdm

import random_tools
from agent import Agent, AgentType, POPULATION_SLICES, HealthStatus
from location import Location
from config import load_config
import utils
from sim_time import SimClock
from activity import ActivityManager

AGENT_INPUT_FILENAME           = "Agents/Agents.pickle"
LOCATION_INPUT_FILENAME        =  "Locations/Locations.pickle"
INITIAL_DISTRIBUTIONS_FILENAME = "Initial_Distributions/initial.pickle"
TRANSITION_MATRIX_FILENAME     = "Transition_Matrices/transition_matrix.pickle"

PARAMETERS_FILENAME    = 'Data/simulation_parameters.yaml'

# ------------------------------------------------[ Config ]------------------------------------
print(f"Loading config from {PARAMETERS_FILENAME}...")
config = load_config(PARAMETERS_FILENAME)
activity_manager = ActivityManager(config['activities'])
clock = SimClock(config['tick_length_s'], config['simulation_length_days'])


# ------------------------------------------------[ Agents ]------------------------------------
print(f'Loading agents from {AGENT_INPUT_FILENAME}...')
with open(AGENT_INPUT_FILENAME, 'rb') as fin:
    agents_by_type = pickle.load(fin)
agents = utils.flatten(agents_by_type.values())




# ------------------------------------------------[ Locations ]------------------------------------
print(f'Loading locations from {LOCATION_INPUT_FILENAME}...')
with open(LOCATION_INPUT_FILENAME, 'rb') as fin:
    locations_by_type = pickle.load(fin)
locations = utils.flatten(locations_by_type.values())




# --------------------------------------[ Transition Matrices ]------------------------------------

print(f"Loading transition matrix from {TRANSITION_MATRIX_FILENAME}...")
with open(TRANSITION_MATRIX_FILENAME, 'rb') as fin:
    activity_transition_matrix = pickle.load(fin)
utils.print_memory_usage()


# ------------------------------------------------[ Locations ]------------------------------------
print('Loading pathogenic data...')

incubation_ticks = clock.days_to_ticks(config['incubation_period_days'])
infectious_ticks = clock.days_to_ticks(config['infectious_period_days'])


def get_p_death_func(p_death_config):
    """Return a function that takes an age and returns
    the absolute probability of death at the end of the
    infectious period"""

    # Make a slow lookup by checking the range.
    #
    # Assumes no overlapping ranges.
    def p_death_slow(age):
        for rng, p in p_death_config:
            if age >= rng[0] and age < rng[1]:
                return p
        return 0.0

    # Make a fast lookup. and use this for integers.
    # Fall through to the slow one if not in the list
    oldest_item = max([x[0][1] for x in p_death_config])
    fast_lookup = [p_death_slow(x) for x in range(0, oldest_item)]
    def p_death_fast(age):
        if age in fast_lookup:
            return fast_lookup[age]
        return p_death_slow(age)

    return p_death_fast

p_death = get_p_death_func(config['probability_of_death'])



# If two individuals, one susceptible and one infectious, spend ten minutes together in location j,
# then prob[j] is the average number of times, out of 10000 trials, that the susceptible will become
# infected:
p_transmit_by_location_type = {x: y for x, y in config['infection_probabilities_per_tick'].items()}



# ------------------------------------------------[ Locations ]------------------------------------
print('Simulating epidemic...')

# Infect a few people
for agent in random.sample(agents, k=config['initial_infections']):
    agent.health = HealthStatus.INFECTED

# FIXME: replace this with state counters for every state in HealthStatus
#
tenminsincubating = [0] * len(agents) # Records how long individual i has been incubating
tenminsinfectious = [0] * len(agents) # Records how long individual i has been infectious



# Using the initial distribution individuals are now assigned starting locations:
print(f"Loading initial activity distributions from {INITIAL_DISTRIBUTIONS_FILENAME}...")
with open(INITIAL_DISTRIBUTIONS_FILENAME, 'rb') as fin:
    initial_activity_distributions = pickle.load(fin)

print(f"Seeding initial activity states and locations...")
for agent in agents:
    allowed_locations = []
    while len(allowed_locations) == 0:
        new_activity           = random_tools.multinoulli_dict(initial_activity_distributions[agent.agetyp])
        allowed_location_types = activity_manager.get_location_types(new_activity)
        allowed_locations      = agent.find_allowed_locations_by_type(allowed_location_types)

        if len(allowed_locations) == 0:
            print(f"Warning: No allowed locations found for agent {agent.inspect()} for activity {new_activity}"\
                  f" (allowed location types={allowed_location_types})."\
                  f"  Will resample from the starting distribution, but this is not ideal.")

    # Do this activity in this location
    agent.set_activity(new_activity, random.choice(list(allowed_locations)))




# ------------------------------------------------[ Simulate! ]------------------------------------
print(f"Simulating outbreak...")
# Finally the epidemic can be simulated. In each ten minute interval, the code first loops through all
# locations, in which the health status of individuals is updated, after which it loops through all 
# individuals, in which the locations of individuals are updated. Note that individuals only change 
# location if the Markov chain generates a new activity. For example, once an individual is inside a shop,
# they cannot move directly to another shop.

# FIXME: replace this with state counters for every state in HealthStatus
deaths = 0 #The total number of deaths
infectious = [] # How many individuals are infectious at each time


# For each agent, record where it is going next.  Entries are (HealthStatus, activity, location)
# 3-tuples, indexed by agent.
next_agent_state = {}
while t := clock.tick():

    print(f"[{t} ticks] {clock.time_elapsed()} elapsed, {clock.time_remaining()} remaining")

    # Using int as math.floor here
    week = int(t.weeks_elapsed())

    for location in locations:
        # Transmission between those at locations
        for agent in location.attendees:

            # TODO
            if agent.health == HealthStatus.EXPOSED:
                pass
            elif agent.health == HealthStatus.INFECTED:
                pass
            elif agent.health == HealthStatus.RECOVERED:
                pass
            elif agent.health == HealthStatus.DEAD:
                pass


    # Update states according to markov chain
    for agent in agents:
        # Select what activity happens next for each individual,
        # based on the transition matrix

        # Read next_agent_state and 
        #  agent.set_activity()
        #  agent.health = 

import code; code.interact(local=locals())






# Cycle through the weeks
for week in tqdm(range(T)):

    # Cycle through the 10-minute intervals
    for tenminute in range(7*144):
        t = week*7*144 + tenminute


    ## ---- 
        week, t

        # Cycle through all locations
        for j in range(len(locations)):

            # Cycle through all agents at that location
            for i in locations[j].attendees:

                # Write the next health state for individuals
                # in the location.
                #
                # This conditional switches on the current health
                # state, i.e. they have different ways of handling
                # each one.
                if (H[0][i] == 1):  #E

                    # Keep count of time in E state
                    tenminsincubating[i] = tenminsincubating[i] + 1

                    # Have we reached the incubation time?
                    if (tenminsincubating[i] < incubation_ticks):
                        H[1][i] = 1 #E
                    else: # Incubation time has been reached
                        H[1][i] = 2 #I

                elif (H[0][i] == 2): #I

                    # Update counters
                    infectious[t]        += 1
                    tenminsinfectious[i] += 1

                    # Has the agent reached the end of the infectious 
                    # period yet?
                    if (tenminsinfectious[i] < infectious_ticks):
                        H[1][i] = 2 #I

                        # With a given p[infection], set others at
                        # this location to Exposed
                        for k in locations[j].attendees:
                            if(H[0][k] == 0): #S --- if the individual is susceptible
                                if random_tools.boolean(p_transmit_by_location_type[locations[j].typ]):
                                    H[1][k] = 1 #E
                    else:
                        # Do they recover or die?  Roll the cosmic dice.
                        if random_tools.boolean(p_death(agents_[i].age)):
                            H[1][i] = 4 #D

                            # Update counters
                            deaths = deaths + 1
                        else:
                            H[1][i] = 3 #R

                elif (H[0][i] == 3): #R
                    H[1][i] = 3 #R

                elif (H[0][i] == 4): #D
                    H[1][i] = 4 #D

        # /for j in range(M) --- locations

        # Update all the agents to change their activity/location
        # (this is the markov chain)
        for i in range(N):

            # Move H[1] -> H[0]
            H[0][i] = H[1][i]

            # Select what activity happens next for each individual
            traj[1][i] = random_tools.multinoulli(Trans[tenminute][agents_[i].agetyp][traj[0][i],:])
            if ( traj[1][i] != traj[0][i] ):    # If activity is different, transition
                locations[agents_[i].location].attendees.remove(i)    # Remove from location
                randloc             = random.randrange(len(LocationListAgent[i][traj[1][i]])) # select new location of the right type

                # move to new location
                agents_[i].location = LocationListAgent[i][traj[1][i]][randloc]
                locations[agents_[i].location].attendees.append(i)

            # Move traj[1] -> traj[0] (activity)
            traj[0][i] = traj[1][i]

    # print('Week', week+1, '/', T, 'complete')

print('Deaths:', deaths)



# ------------------------------------------------[ Locations ]------------------------------------
print('Saving results...')
workbook = xlsxwriter.Workbook('Results/ABM_Results.xlsx') 
worksheet = workbook.add_worksheet()

for t in range(T*7*144):
    worksheet.write(t,0, infectious[t])
workbook.close()

print('Done.')
